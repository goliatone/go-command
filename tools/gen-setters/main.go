package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
)

// optionInfo holds the information about each Option function
type optionInfo struct {
	name       string
	paramName  string
	paramType  string
	fieldName  string
	importPath string
	typePkg    string
}

// Store the Option type's receiver type
type generatorContext struct {
	optionReceiverType string
}

var (
	inputFile  = flag.String("input", "options.go", "Input file containing the options (default: options.go)")
	outputFile = flag.String("output", "", "Output file for generated code (default: {input}_setters.go)")
	pkgName    = flag.String("package", "", "Package name for generated code (default: derived from input file)")
)

func main() {
	flag.Parse()

	// Validate input file
	if *inputFile == "" {
		log.Fatal("Input file must be specified")
	}

	// Set default output file if not specified
	if *outputFile == "" {
		ext := filepath.Ext(*inputFile)
		basename := strings.TrimSuffix(*inputFile, ext)
		*outputFile = basename + "_setters" + ext
	}

	// Convert to absolute paths
	absInput, err := filepath.Abs(*inputFile)
	if err != nil {
		log.Fatalf("Failed to get absolute path for input file: %v", err)
	}

	absOutput, err := filepath.Abs(*outputFile)
	if err != nil {
		log.Fatalf("Failed to get absolute path for output file: %v", err)
	}

	if err := generateSetters(absInput, absOutput); err != nil {
		log.Fatalf("Failed to generate setters: %v", err)
	}
}

func generateSetters(inputPath, outputPath string) error {
	// Parse the source file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputPath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse input file: %v", err)
	}

	// Find the Option type's receiver
	optionType, err := findOptionType(node)
	if err != nil {
		return fmt.Errorf("failed to determine Option type: %v", err)
	}

	ctx := &generatorContext{
		optionReceiverType: optionType,
	}

	// Determine package name
	actualPkgName := node.Name.Name
	if *pkgName != "" {
		actualPkgName = *pkgName
	}

	// Collect option functions information
	options := make([]optionInfo, 0)
	ast.Inspect(node, func(n ast.Node) bool {
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			if strings.HasPrefix(funcDecl.Name.Name, "With") {
				opt := parseOptionFunc(funcDecl)
				if opt != nil {
					options = append(options, *opt)
				}
			}
		}
		return true
	})

	imports := collectImports(node)

	// Generate the code
	f := jen.NewFile(actualPkgName)

	// This comment indicates to not edit by hand.
	f.HeaderComment("// Code generated by gen_setters.go; DO NOT EDIT.\n")

	for _, imp := range imports {
		f.ImportName(imp.Path.Value, "")
	}

	// Generate the WithConfigurator function
	generateConfigurator(f, options, ctx)
	f.Line()

	// Generate interfaces and setter functions
	for _, opt := range options {
		generateInterface(f, opt)
		f.Line()
		generateSetterFunc(f, opt, ctx)
		f.Line()
	}

	// Create output directory if it doesn't exist
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// Write the generated code to file
	out, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer out.Close()

	if err := f.Render(out); err != nil {
		return fmt.Errorf("failed to render code: %v", err)
	}

	fmt.Printf("Successfully generated setters in %s\n", outputPath)
	return nil
}

func parseOptionFunc(funcDecl *ast.FuncDecl) *optionInfo {
	// Skip if not an Option function
	if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) != 1 {
		return nil
	}

	// Get parameter information
	if len(funcDecl.Type.Params.List) != 1 {
		return nil
	}
	param := funcDecl.Type.Params.List[0]

	// Get the field being set by analyzing the function body
	var fieldName string
	ast.Inspect(funcDecl.Body, func(n ast.Node) bool {
		if assign, ok := n.(*ast.AssignStmt); ok {
			if sel, ok := assign.Lhs[0].(*ast.SelectorExpr); ok {
				fieldName = sel.Sel.Name
			}
		}
		return true
	})

	if fieldName == "" {
		return nil
	}

	// Extract parameter type and import information
	var paramType, importPath, typePkg string
	switch t := param.Type.(type) {
	case *ast.StarExpr:
		if sel, ok := t.X.(*ast.SelectorExpr); ok {
			typePkg = sel.X.(*ast.Ident).Name
			paramType = "*" + typePkg + "." + sel.Sel.Name
			if typePkg == "time" {
				importPath = "time"
			}
		} else if ident, ok := t.X.(*ast.Ident); ok {
			paramType = "*" + ident.Name
		}
	case *ast.SelectorExpr:
		typePkg = t.X.(*ast.Ident).Name
		paramType = typePkg + "." + t.Sel.Name
		if typePkg == "time" {
			importPath = "time"
		} else if typePkg == "io" {
			importPath = "io"
		}
	case *ast.Ident:
		paramType = t.Name
	case *ast.FuncType:
		paramType = "func(error)"
	}

	return &optionInfo{
		name:       funcDecl.Name.Name,
		paramName:  param.Names[0].Name,
		paramType:  paramType,
		fieldName:  fieldName,
		importPath: importPath,
		typePkg:    typePkg,
	}
}

func generateInterface(f *jen.File, opt optionInfo) {
	// Generate getter interface name
	getterName := strings.TrimPrefix(opt.name, "With") + "Getter"
	methodName := "Get" + strings.TrimPrefix(opt.name, "With")

	// Create the return type statement
	var returnType jen.Code
	switch {
	case strings.HasPrefix(opt.paramType, "*time."):
		returnType = jen.Op("*").Qual("time", strings.TrimPrefix(opt.paramType, "*time."))
	case strings.HasPrefix(opt.paramType, "io."):
		returnType = jen.Qual("io", strings.TrimPrefix(opt.paramType, "io."))
	case opt.paramType == "func(error)":
		returnType = jen.Func().Params(jen.Error())
	default:
		returnType = jen.Id(opt.paramType)
	}

	// Generate interface
	f.Type().Id(getterName).Interface(
		jen.Id(methodName).Params().Add(returnType),
	)
}

func generateSetterFunc(f *jen.File, opt optionInfo, ctx *generatorContext) {
	// Generate setter function name
	setterName := opt.name + "Setter"
	getterInterface := strings.TrimPrefix(opt.name, "With") + "Getter"
	methodName := "Get" + strings.TrimPrefix(opt.name, "With")

	// Generate setter function
	f.Func().Id(setterName).Params(
		jen.Id("s").Id(getterInterface),
	).Id("Option").Block(
		jen.Return(
			jen.Func().Params(
				jen.Id("cs").Op("*").Id(ctx.optionReceiverType),
			).Block(
				jen.If(jen.Id("s").Op("!=").Nil()).Block(
					jen.Id("cs").Dot(opt.fieldName).Op("=").Id("s").Dot(methodName).Call(),
				),
			),
		),
	)
}

// Generate WithConfigurator function
func generateConfigurator(f *jen.File, options []optionInfo, ctx *generatorContext) {
	f.Line()
	f.Comment("WithConfigurator sets multiple options from")
	f.Comment("a single configuration struct that implements")
	f.Comment("one or more Getter interfaces")
	f.Func().Id("WithConfigurator").Params(
		jen.Id("i").Interface(),
	).Id("Option").Block(
		jen.Return(
			jen.Func().Params(
				jen.Id("cs").Op("*").Id(ctx.optionReceiverType),
			).Block(
				generateConfiguratorBody(options)...,
			),
		),
	)
}

func generateConfiguratorBody(options []optionInfo) []jen.Code {
	statements := make([]jen.Code, 0, len(options))
	statements = append(statements, jen.Line())
	for _, opt := range options {
		getterName := strings.TrimPrefix(opt.name, "With") + "Getter"
		methodName := "Get" + strings.TrimPrefix(opt.name, "With")

		// Generate if statement with type assertion for each getter interface
		statements = append(statements,
			jen.If(
				jen.List(jen.Id("s"), jen.Id("ok")).Op(":=").Id("i").Assert(jen.Id(getterName)),
				jen.Id("ok"),
			).Block(
				jen.Id("cs").Dot(opt.fieldName).Op("=").Id("s").Dot(methodName).Call(),
			).Line(),
		)
	}

	return statements
}

func findOptionType(node *ast.File) (string, error) {
	var optionType string

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == "Option" {
				if funcType, ok := typeSpec.Type.(*ast.FuncType); ok {
					if len(funcType.Params.List) == 1 {
						// Get the receiver type from the Option function parameter
						if starExpr, ok := funcType.Params.List[0].Type.(*ast.StarExpr); ok {
							if ident, ok := starExpr.X.(*ast.Ident); ok {
								optionType = ident.Name
							}
						}
					}
				}
			}
		}
		return true
	})

	if optionType == "" {
		return "", fmt.Errorf("could not find Option type definition or determine receiver type")
	}

	return optionType, nil
}

func collectImports(f *ast.File) []*ast.ImportSpec {
	var imports []*ast.ImportSpec
	for _, imp := range f.Imports {
		imports = append(imports, imp)
	}
	return imports
}
